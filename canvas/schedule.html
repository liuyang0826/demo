<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="author" content="018269">
  <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no,viewport-fit=cover">
  <title>这波啊，这波就是要起飞~</title>
  <style>
  * { margin: 0;padding: 0; }

  canvas { width: 100vw;height: 100vh;display: block;}
  </style>
  <script src="https://cdn.bootcdn.net/ajax/libs/vue/2.6.10/vue.min.js"></script>
</head>
<body>
<div id="root">
  <canvas id="canvas"
          ref="canvas"
          @click="handleClick"
          @mousewheel="handleMousewheel"
          @mousedown="handleMouseDown"></canvas>
</div>
<script>
// 线
function drawLine (ctx, pointList, { color = "#000", width = 2, lineJoin = "round", isDash = false } = {}) {
  if (pointList.length < 2) {
    return;
  }
  ctx.beginPath();
  ctx.setLineDash(isDash ? [10, 6] : []);
  let start = pointList[0];
  ctx.moveTo(start[0], start[1]);
  for (let i = 1; i < pointList.length; i++) {
    let cur = pointList[i];
    ctx.lineTo(cur[0], cur[1]);
  }
  ctx.strokeStyle = color;
  ctx.lineWidth = width;
  ctx.lineJoin = lineJoin;
  ctx.stroke();
}

// 矩形
function drawRect (ctx, { x, y, w, h }, { borderColor = "#999", borderWidth = 2, color = "#eaeaea", borderTop = true, borderRight = true, borderBottom = true, borderLeft = true } = {}) {
  ctx.beginPath();
  ctx.setLineDash([]);
  ctx.strokeStyle = borderColor;
  ctx.lineWidth = borderWidth;
  if (borderTop && borderRight && borderBottom && borderLeft) {
    ctx.rect(x, y, w, h);
    ctx.stroke();
  } else {
    if (borderTop) {
      ctx.moveTo(x, y);
      ctx.lineTo(x + w, y);
    }
    if (borderRight) {
      ctx.moveTo(x + w, y);
      ctx.lineTo(x + w, y + h);
    }
    if (borderBottom) {
      ctx.moveTo(x + w, y + h);
      ctx.lineTo(x, y + h);
    }
    if (borderLeft) {
      ctx.moveTo(x, y + h);
      ctx.lineTo(x, y);
    }
    ctx.stroke();
    ctx.moveTo(x, y);
    ctx.lineTo(x + w, y);
    ctx.lineTo(x + w, y + h);
    ctx.lineTo(x, y + h);
  }
  ctx.fillStyle = color;
  ctx.fill();
}

// 文字
function drawText (ctx, { text, x, y }, { color = "#333" } = {}) {
  ctx.beginPath();
  ctx.font = "14px bold PingFang-SC-Bold";
  ctx.fillStyle = color;
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(text, x, y);
}

// 裁减矩形区域 溢出隐藏
function clipRect (ctx, { x, y, w, h }, execute) {
  ctx.save();
  ctx.rect(x, y, w, h);
  ctx.clip();
  execute();
  ctx.restore();
}
</script>
<script>

// 配置项
const configMixin = Vue.mixin({
  data () {
    return {
      dateRange: 180,
      lineSpacePX: 100,
      padding: {
        left: 100,
        right: 40,
        top: 100,
        bottom: 100
      },
      rectHeight: 50,
      splitTime: new Date().getTime(),
      leftSpacePercent: 0.5,
      scale: 1,
      scaleSpeed: 0.04,
      advanceSpaceTime: 1.5 * 60 * 1000
    };
  }
});

// 工具类
const utilMixin = Vue.mixin({
  methods: {
    makeRectByPlan (plan, xIndex) {
      const startTime = plan.startTime;
      const endTime = plan.endTime;
      return {
        x: (startTime - this.startTime) * this.ms2px + this.padding.left,
        y: xIndex * this.lineSpacePX + this.padding.top - this.rectHeight / 2,
        w: ~~((endTime - startTime) * this.ms2px),
        h: this.rectHeight
      };
    },
    eventToCanvas (e) {
      return {
        x: e.clientX,
        y: e.clientY
      };
    },
    // 事件获取方块
    getRectInfoByEvent (e) {
      const { x, y } = this.eventToCanvas(e);
      const { padding, lineSpacePX, dataList, id2rect } = this;
      let index = ~~((y - padding.top + lineSpacePX / 2) / lineSpacePX);
      if (index < dataList.length) {
        let planList = dataList[index].planList;
        let first = planList[0];
        if (first) {
          let rect = id2rect[first.id];
          if (y >= rect.y && y <= rect.y + rect.h) {
            for (let yIndex = planList.length - 1; yIndex >= 0; yIndex--) {
              let rectBoundary = id2rect[planList[yIndex].id];
              if (x <= rectBoundary.x + rectBoundary.w && x >= rectBoundary.x) {
                return {
                  xIndex: index,
                  yIndex: yIndex,
                  id: planList[yIndex].id
                };
              }
            }
          }
        }
      }
    },
    // 获取插入位置信息
    getInsertInfoByEvent (e) {
      let { x, y } = this.eventToCanvas(e);
      // const x = this.curRectInfo.rect.rectBoundary.x;
      x -= this.curRectInfo.offsetX;
      const { padding, lineSpacePX, dataList, id2rect } = this;
      let xIndex = ~~((y - padding.top + lineSpacePX / 2) / lineSpacePX);
      // if (xIndex === this.curRectInfo.xIndex) return;
      if (xIndex >= dataList.length) {
        xIndex = dataList.length - 1;
      }
      let planList = this.dataList[xIndex].planList;
      let isOverlay = false;
      let yIndex = 0;
      for (; yIndex < planList.length; yIndex++) {
        let rect = id2rect[planList[yIndex].id];
        if (x <= rect.x + rect.w) {
          isOverlay = true;
          if (x < rect.x) {
            yIndex--;
            isOverlay = false;
          }
          break;
        }
      }
      return { xIndex, yIndex: yIndex + 1, isOverlay };
    },
    // 顺移时间
    advanceTime (xIndex, yIndex) {
      const planList = this.dataList[xIndex].planList;
      const space = this.advanceSpaceTime;
      let leftPlan = planList[yIndex];
      let rightIndex = yIndex + 1;
      while (rightIndex < planList.length) {
        const rightPlan = planList[rightIndex];
        if (rightPlan.startTime - leftPlan.endTime < space) {
          let advance = (leftPlan.endTime - rightPlan.startTime) + space;
          rightPlan.startTime += advance;
          rightPlan.endTime += advance;
        } else {
          break;
        }
        this.id2rect[rightPlan.id] = this.makeRectByPlan(rightPlan, xIndex);
        rightIndex++;
        leftPlan = rightPlan;
      }
    }
  }
});

// 视图渲染
const renderMixin = Vue.mixin({
  data () {
    return {
      width: 0,
      height: 0
    };
  },
  computed: {
    ms2px () {
      const { width, padding, dateRange, scale } = this;
      return (width - padding.left - padding.right) / dateRange / 60 / 1000 * scale;
    },
    startTime () {
      const { width, padding, leftSpacePercent, splitTime, ms2px } = this;
      return splitTime - (width - padding.left - padding.right) * leftSpacePercent / ms2px;
    },
    id2plan () {
      const map = {};
      this.dataList.forEach((item) => {
        item.planList.forEach((d) => {
          map[d.id] = d;
        });
      });
      return map;
    },
    id2rect () {
      const map = {};
      this.dataList.forEach((item, xIndex) => {
        item.planList.forEach((plan) => {
          map[plan.id] = this.makeRectByPlan(plan, xIndex);
        });
      });
      return map;
    }
  },
  methods: {
    render ({ afterRender, forceUpdate = false } = {}) {
      const { ctx, offCtx, padding, width, height } = this;
      ctx.clearRect(0, 0, width, height);
      if (forceUpdate) {
        offCtx.clearRect(0, 0, width, height);
        this.renderLines();
        clipRect(offCtx, { x: padding.left, y: 0, w: width - padding.right - padding.left, h: height }, () => {
          this.renderPlans();
          this.renderConcatLines();
        });
        this.renderSplitLine();
      }
      this.renderOffCanvas();
      afterRender && afterRender();
    },
    renderOffCanvas () {
      const { ctx, offCanvas, width, height } = this;
      ctx.drawImage(offCanvas, 0, 0, width, height);
    },
    // 时间线
    renderLines () {
      const { offCtx, lineSpacePX, padding, width, dataList } = this;
      dataList.forEach((item, i) => {
        let curY = i * lineSpacePX + padding.top;
        drawLine(offCtx, [[padding.left, curY], [width - padding.right, curY]]);
        drawText(offCtx, { text: item.name, x: 50, y: curY });
      });
    },
    // 渲染计划方块
    renderPlans () {
      const { dataList, id2rect, offCtx } = this;
      dataList.forEach((item) => {
        item.planList.forEach((item) => {
          this.renderPlan(offCtx, id2rect[item.id], item);
        });
      });
    },
    renderPlan (ctx, { x, y, w, h }, item) {
      const { splitTime, ms2px, rectHeight } = this;
      const startTime = item.startTime;
      const endTime = item.endTime;
      // 时间线分割
      if (startTime <= splitTime && splitTime <= endTime) {
        let leftRectBoundary = {
          x: x,
          y: y,
          w: (splitTime - startTime) * ms2px,
          h: rectHeight,
        };
        drawRect(ctx, leftRectBoundary, {
          borderRight: false
        });
        drawRect(ctx, {
          x: x + leftRectBoundary.w,
          y: y,
          w: w - (splitTime - startTime) * ms2px,
          h: rectHeight,
        }, {
          borderLeft: false,
          color: "orange"
        });
      } else if (startTime < splitTime) {
        drawRect(ctx, { x, y, w, h });
      } else {
        drawRect(ctx, { x, y, w, h }, {
          color: "orange"
        });
      }
      drawText(ctx, {
        text: item.name,
        x: x + w / 2,
        y: y + h / 2,
      });
    },
    // 渲染关系线
    renderConcatLines () {
      const { offCtx, splitTime, rectHeight, id2plan, id2rect, dataList } = this;
      dataList.forEach((item) => {
        item.planList.forEach((item) => {
          let concatPlan = id2plan[item.concatId];
          if (concatPlan) {
            const endTime = item.endTime;
            const concatStartTime = concatPlan.startTime;
            if (endTime > concatStartTime) {
              return;
            }
            let startRect = id2rect[item.id];
            let endRect = id2rect[concatPlan.id];
            drawLine(offCtx, [
              [startRect.x + startRect.w, startRect.y + rectHeight / 2],
              [endRect.x, endRect.y + rectHeight / 2]
            ], {
              isDash: true,
              color: endTime > splitTime || concatStartTime > splitTime ? "#f00" : "#999"
            });
          }
        });
      });
    },
    // 时间分割线
    renderSplitLine () {
      const { offCtx, startTime, splitTime, padding, ms2px, height } = this;
      const curX = (splitTime - startTime) * ms2px + padding.left;
      drawLine(offCtx, [[curX, 0], [curX, height]], { color: "#999", isDash: true });
    }
  }
});

// 事件处理
const eventMixin = Vue.mixin({
  methods: {
    handleClick (e) {
      const { getRectByPoint } = this;
      // console.log(getRectByPoint({ x: e.clientX, y: e.clientY }));
    },
    handleMousewheel (e) {
      this.scale += this.scaleSpeed * (e.wheelDelta > 0 ? 1 : -1);
      this.scale <= 0 && (this.scale = 0.01);
      this.render({ forceUpdate: true });
    },
    handleMouseDown (e) {
      const { getRectInfoByEvent, id2rect, id2plan } = this;
      const rectInfo = getRectInfoByEvent(e);
      if (rectInfo && (!this.beforeMove || this.beforeMove(id2plan[rectInfo.id]))) {
        const curRect = id2rect[rectInfo.id];
        this.curRectInfo = {
          ...rectInfo,
          offsetX: e.clientX - curRect.x,
          offsetY: e.clientY - curRect.y
        };
        document.addEventListener("mousemove", this.handleMousemove);
        document.addEventListener("mouseup", this.handleMouseup);
      }
    },
    handleMousemove (e) {
      this.render({
        afterRender: () => {
          const curRectId = this.curRectInfo.id;
          const rect = { ...this.id2rect[curRectId] };
          const position = this.eventToCanvas(e);
          rect.x = position.x - this.curRectInfo.offsetX;
          rect.y = position.y - this.curRectInfo.offsetY;
          this.renderPlan(this.ctx, rect, this.id2plan[curRectId]);
        }
      });
    },
    handleMouseup (e) {
      document.removeEventListener("mousemove", this.handleMousemove);
      document.removeEventListener("mouseup", this.handleMouseup);
      const insertInfo = this.getInsertInfoByEvent(e);
      const { xIndex, yIndex, isOverlay } = insertInfo;
      const { padding, startTime, ms2px, id2rect, id2plan, curRectInfo } = this;

      const plan = id2plan[curRectInfo.id];
      const position = this.eventToCanvas(e);
      plan.startTime = (position.x - curRectInfo.offsetX - padding.left) / ms2px + startTime;
      plan.endTime = plan.startTime + id2rect[curRectInfo.id].w / ms2px;
      id2rect[curRectInfo.id] = this.makeRectByPlan(plan, xIndex);
      this.dataList[curRectInfo.xIndex].planList.splice(curRectInfo.yIndex, 1);
      let insertYIndex = yIndex;
      let advanceYIndex = yIndex;
      // 本行内移动
      if (xIndex === curRectInfo.xIndex && yIndex > curRectInfo.yIndex) {
        insertYIndex--;
        advanceYIndex--;
      }
      if (isOverlay && advanceYIndex > 0) {
        advanceYIndex--;
      }
      this.dataList[xIndex].planList.splice(insertYIndex, 0, plan);
      this.advanceTime(xIndex, advanceYIndex);
      this.render({ forceUpdate: true });
    }
  }
});

// 业务逻辑处理
const businessMixin = Vue.mixin({
  methods: {
    beforeMove (plan) {
      // return plan.startTime > this.splitTime);
      return true;
    },
    beforeMoveEnd () {}
  }
});

new Vue({
  el: "#root",
  mixins: [configMixin, utilMixin, renderMixin, eventMixin],
  data: {
    dataList: []
  },
  mounted () {
    this.dataList = Object.freeze((function () {
      let idMap = {};

      function getConcatId () {
        let id = ~~(Math.random() * 400);
        if (idMap[id]) {
          return getConcatId();
        } else {
          idMap[id] = true;
          return id;
        }
      }

      let id = 1;
      return Array.from({ length: 8 }).map((_, index) => {
        let start = new Date().getTime() - ~~(Math.random() * 75 * 60 * 1000);
        return {
          name: (index + 1) + "#高炉",
          planList: Array.from({ length: 16 }).map((_, i) => {
            let startTemp = start;
            let end = startTemp + ~~(6 * 60 * 1000 * (Math.random() + 0.5));
            start = end + ~~(2 * 60 * 1000 * (Math.random() + 0.25));
            let concatId = getConcatId();
            return {
              id: id++,
              name: "铁次A" + (i + 1),
              startTime: startTemp,
              endTime: end,
              concatId: concatId
            };
          })
        };
      });
    })());

    const canvas = this.$refs.canvas;
    const offCanvas = this.offCanvas = document.createElement("canvas");

    this.width = offCanvas.width = canvas.width = canvas.offsetWidth;
    this.height = offCanvas.height = canvas.height = canvas.offsetHeight;

    this.ctx = canvas.getContext("2d");
    this.offCtx = offCanvas.getContext("2d");
    this.render({ forceUpdate: true });
  }
});
</script>
</body>
</html>
